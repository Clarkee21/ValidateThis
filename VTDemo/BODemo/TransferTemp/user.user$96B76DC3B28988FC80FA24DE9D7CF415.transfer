<cffunction name="init" access="public" returntype="transfer.com.TransferObject" default="transfer.com.TransferObject" hint="Constructor for Transfer class user.user" output="false">
<cfargument name="transfer" type="transfer.com.Transfer" required="true" hint="The Transfer library">
<cfargument name="utility" type="transfer.com.util.Utility" required="true" hint="The Utility object">
<cfargument name="nullable" type="transfer.com.sql.Nullable" required="true" hint="The Nullable lookup object">
<cfargument name="thisObject" type="transfer.com.TransferObject" required="true" hint="What is determined to be the base 'this' object for this TransferObject">
<cfscript>
instance = StructNew();
setThisObject(arguments.thisObject);
setTransfer(arguments.transfer);
setUtility(arguments.utility);
setSystem(createObject("java", "java.lang.System"));
setNullable(arguments.nullable);
setClassName("user.user");
setIsDirty(true);
setIsPersisted(false);
setIsClone(false);
setUserId(getNullable().getNullNumeric(getClassName(), "UserId"));
setUserName("");
setUserPass("");
setNickname("");
setSalutation("");
setFirstName("");
setLastName("");
setLikeCheese(0);
setLikeChocolate(0);
setLikeOther("");
setLastUpdateTimestamp(Now());
setAllowCommunication(0);
setHowMuch(0);
setCommunicationMethod("");
setLoaded(StructNew());
setUserGroupisLoaded(true);
if(StructKeyExists(this, "configure") OR StructKeyExists(variables, "configure"))
{
configure();
}
return this;
</cfscript>
</cffunction>

<cffunction name="equalsTransfer" access="public" returntype="boolean" default="boolean" hint="If an object is persisted, returns true if they are of the same class and same id. If not, returns true if they are the same object." output="false">
<cfargument name="transfer" type="transfer.com.TransferObject" required="true" hint="The TransferObject to test against">
<cfscript>
if(getIsPersisted())
{
if(getClassName() neq arguments.transfer.getClassName())
{
return false;
}
return (getUserId() eq arguments.transfer.getUserId());
}
else
{
return sameTransfer(arguments.transfer);
}
</cfscript>
</cffunction>

<cffunction name="getUserId" access="public" returntype="numeric" default="numeric" hint="Accessor for property UserId" output="false">
<cfscript>
return instance.UserId;
</cfscript>
</cffunction>

<cffunction name="setUserId" access="public" returntype="void" default="void" hint="Mutator for property UserId" output="false">
<cfargument name="UserId" type="numeric" required="true" hint="The value to set UserId to">
<cfscript>
if(NOT StructKeyExists(instance, "UserId") OR getUserId() neq arguments.UserId)
{
instance.UserId = getUtility().trimZero(arguments.UserId);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getUserName" access="public" returntype="string" default="string" hint="Accessor for property UserName" output="false">
<cfscript>
return instance.UserName;
</cfscript>
</cffunction>

<cffunction name="setUserName" access="public" returntype="void" default="void" hint="Mutator for property UserName" output="false">
<cfargument name="UserName" type="string" required="true" hint="The value to set UserName to">
<cfscript>
if(NOT StructKeyExists(instance, "UserName") OR Compare(getUserName(), arguments.UserName) neq 0)
{
instance.UserName = (arguments.UserName);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getUserPass" access="public" returntype="string" default="string" hint="Accessor for property UserPass" output="false">
<cfscript>
return instance.UserPass;
</cfscript>
</cffunction>

<cffunction name="setUserPass" access="public" returntype="void" default="void" hint="Mutator for property UserPass" output="false">
<cfargument name="UserPass" type="string" required="true" hint="The value to set UserPass to">
<cfscript>
if(NOT StructKeyExists(instance, "UserPass") OR Compare(getUserPass(), arguments.UserPass) neq 0)
{
instance.UserPass = (arguments.UserPass);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getNickname" access="public" returntype="string" default="string" hint="Accessor for property Nickname" output="false">
<cfscript>
return instance.Nickname;
</cfscript>
</cffunction>

<cffunction name="setNickname" access="public" returntype="void" default="void" hint="Mutator for property Nickname" output="false">
<cfargument name="Nickname" type="string" required="true" hint="The value to set Nickname to">
<cfscript>
if(NOT StructKeyExists(instance, "Nickname") OR Compare(getNickname(), arguments.Nickname) neq 0)
{
instance.Nickname = (arguments.Nickname);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getSalutation" access="public" returntype="string" default="string" hint="Accessor for property Salutation" output="false">
<cfscript>
return instance.Salutation;
</cfscript>
</cffunction>

<cffunction name="setSalutation" access="public" returntype="void" default="void" hint="Mutator for property Salutation" output="false">
<cfargument name="Salutation" type="string" required="true" hint="The value to set Salutation to">
<cfscript>
if(NOT StructKeyExists(instance, "Salutation") OR Compare(getSalutation(), arguments.Salutation) neq 0)
{
instance.Salutation = (arguments.Salutation);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setSalutationNull" access="public" returntype="void" default="void" hint="Set Salutation to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullstring(getClassName(), "Salutation");
setSalutation(nullValue);
</cfscript>
</cffunction>

<cffunction name="getSalutationIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not Salutation's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullstring(getThisObject(), "Salutation", getSalutation());
</cfscript>
</cffunction>

<cffunction name="getFirstName" access="public" returntype="string" default="string" hint="Accessor for property FirstName" output="false">
<cfscript>
return instance.FirstName;
</cfscript>
</cffunction>

<cffunction name="setFirstName" access="public" returntype="void" default="void" hint="Mutator for property FirstName" output="false">
<cfargument name="FirstName" type="string" required="true" hint="The value to set FirstName to">
<cfscript>
if(NOT StructKeyExists(instance, "FirstName") OR Compare(getFirstName(), arguments.FirstName) neq 0)
{
instance.FirstName = (arguments.FirstName);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setFirstNameNull" access="public" returntype="void" default="void" hint="Set FirstName to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullstring(getClassName(), "FirstName");
setFirstName(nullValue);
</cfscript>
</cffunction>

<cffunction name="getFirstNameIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not FirstName's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullstring(getThisObject(), "FirstName", getFirstName());
</cfscript>
</cffunction>

<cffunction name="getLastName" access="public" returntype="string" default="string" hint="Accessor for property LastName" output="false">
<cfscript>
return instance.LastName;
</cfscript>
</cffunction>

<cffunction name="setLastName" access="public" returntype="void" default="void" hint="Mutator for property LastName" output="false">
<cfargument name="LastName" type="string" required="true" hint="The value to set LastName to">
<cfscript>
if(NOT StructKeyExists(instance, "LastName") OR Compare(getLastName(), arguments.LastName) neq 0)
{
instance.LastName = (arguments.LastName);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setLastNameNull" access="public" returntype="void" default="void" hint="Set LastName to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullstring(getClassName(), "LastName");
setLastName(nullValue);
</cfscript>
</cffunction>

<cffunction name="getLastNameIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not LastName's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullstring(getThisObject(), "LastName", getLastName());
</cfscript>
</cffunction>

<cffunction name="getLikeCheese" access="public" returntype="numeric" default="numeric" hint="Accessor for property LikeCheese" output="false">
<cfscript>
return instance.LikeCheese;
</cfscript>
</cffunction>

<cffunction name="setLikeCheese" access="public" returntype="void" default="void" hint="Mutator for property LikeCheese" output="false">
<cfargument name="LikeCheese" type="numeric" required="true" hint="The value to set LikeCheese to">
<cfscript>
if(NOT StructKeyExists(instance, "LikeCheese") OR getLikeCheese() neq arguments.LikeCheese)
{
instance.LikeCheese = getUtility().trimZero(arguments.LikeCheese);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setLikeCheeseNull" access="public" returntype="void" default="void" hint="Set LikeCheese to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullnumeric(getClassName(), "LikeCheese");
setLikeCheese(nullValue);
</cfscript>
</cffunction>

<cffunction name="getLikeCheeseIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not LikeCheese's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullnumeric(getThisObject(), "LikeCheese", getLikeCheese());
</cfscript>
</cffunction>

<cffunction name="getLikeChocolate" access="public" returntype="numeric" default="numeric" hint="Accessor for property LikeChocolate" output="false">
<cfscript>
return instance.LikeChocolate;
</cfscript>
</cffunction>

<cffunction name="setLikeChocolate" access="public" returntype="void" default="void" hint="Mutator for property LikeChocolate" output="false">
<cfargument name="LikeChocolate" type="numeric" required="true" hint="The value to set LikeChocolate to">
<cfscript>
if(NOT StructKeyExists(instance, "LikeChocolate") OR getLikeChocolate() neq arguments.LikeChocolate)
{
instance.LikeChocolate = getUtility().trimZero(arguments.LikeChocolate);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setLikeChocolateNull" access="public" returntype="void" default="void" hint="Set LikeChocolate to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullnumeric(getClassName(), "LikeChocolate");
setLikeChocolate(nullValue);
</cfscript>
</cffunction>

<cffunction name="getLikeChocolateIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not LikeChocolate's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullnumeric(getThisObject(), "LikeChocolate", getLikeChocolate());
</cfscript>
</cffunction>

<cffunction name="getLikeOther" access="public" returntype="string" default="string" hint="Accessor for property LikeOther" output="false">
<cfscript>
return instance.LikeOther;
</cfscript>
</cffunction>

<cffunction name="setLikeOther" access="public" returntype="void" default="void" hint="Mutator for property LikeOther" output="false">
<cfargument name="LikeOther" type="string" required="true" hint="The value to set LikeOther to">
<cfscript>
if(NOT StructKeyExists(instance, "LikeOther") OR Compare(getLikeOther(), arguments.LikeOther) neq 0)
{
instance.LikeOther = (arguments.LikeOther);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setLikeOtherNull" access="public" returntype="void" default="void" hint="Set LikeOther to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullstring(getClassName(), "LikeOther");
setLikeOther(nullValue);
</cfscript>
</cffunction>

<cffunction name="getLikeOtherIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not LikeOther's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullstring(getThisObject(), "LikeOther", getLikeOther());
</cfscript>
</cffunction>

<cffunction name="getLastUpdateTimestamp" access="public" returntype="date" default="date" hint="Accessor for property LastUpdateTimestamp" output="false">
<cfscript>
return instance.LastUpdateTimestamp;
</cfscript>
</cffunction>

<cffunction name="setLastUpdateTimestamp" access="public" returntype="void" default="void" hint="Mutator for property LastUpdateTimestamp" output="false">
<cfargument name="LastUpdateTimestamp" type="date" required="true" hint="The value to set LastUpdateTimestamp to">
<cfscript>
if(NOT StructKeyExists(instance, "LastUpdateTimestamp") OR getLastUpdateTimestamp() neq arguments.LastUpdateTimestamp)
{
instance.LastUpdateTimestamp = (arguments.LastUpdateTimestamp);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="getAllowCommunication" access="public" returntype="numeric" default="numeric" hint="Accessor for property AllowCommunication" output="false">
<cfscript>
return instance.AllowCommunication;
</cfscript>
</cffunction>

<cffunction name="setAllowCommunication" access="public" returntype="void" default="void" hint="Mutator for property AllowCommunication" output="false">
<cfargument name="AllowCommunication" type="numeric" required="true" hint="The value to set AllowCommunication to">
<cfscript>
if(NOT StructKeyExists(instance, "AllowCommunication") OR getAllowCommunication() neq arguments.AllowCommunication)
{
instance.AllowCommunication = getUtility().trimZero(arguments.AllowCommunication);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setAllowCommunicationNull" access="public" returntype="void" default="void" hint="Set AllowCommunication to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullnumeric(getClassName(), "AllowCommunication");
setAllowCommunication(nullValue);
</cfscript>
</cffunction>

<cffunction name="getAllowCommunicationIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not AllowCommunication's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullnumeric(getThisObject(), "AllowCommunication", getAllowCommunication());
</cfscript>
</cffunction>

<cffunction name="getHowMuch" access="public" returntype="numeric" default="numeric" hint="Accessor for property HowMuch" output="false">
<cfscript>
return instance.HowMuch;
</cfscript>
</cffunction>

<cffunction name="setHowMuch" access="public" returntype="void" default="void" hint="Mutator for property HowMuch" output="false">
<cfargument name="HowMuch" type="numeric" required="true" hint="The value to set HowMuch to">
<cfscript>
if(NOT StructKeyExists(instance, "HowMuch") OR getHowMuch() neq arguments.HowMuch)
{
instance.HowMuch = getUtility().trimZero(arguments.HowMuch);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setHowMuchNull" access="public" returntype="void" default="void" hint="Set HowMuch to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullnumeric(getClassName(), "HowMuch");
setHowMuch(nullValue);
</cfscript>
</cffunction>

<cffunction name="getHowMuchIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not HowMuch's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullnumeric(getThisObject(), "HowMuch", getHowMuch());
</cfscript>
</cffunction>

<cffunction name="getCommunicationMethod" access="public" returntype="string" default="string" hint="Accessor for property CommunicationMethod" output="false">
<cfscript>
return instance.CommunicationMethod;
</cfscript>
</cffunction>

<cffunction name="setCommunicationMethod" access="public" returntype="void" default="void" hint="Mutator for property CommunicationMethod" output="false">
<cfargument name="CommunicationMethod" type="string" required="true" hint="The value to set CommunicationMethod to">
<cfscript>
if(NOT StructKeyExists(instance, "CommunicationMethod") OR Compare(getCommunicationMethod(), arguments.CommunicationMethod) neq 0)
{
instance.CommunicationMethod = (arguments.CommunicationMethod);
setIsDirty(true);
}
</cfscript>
</cffunction>

<cffunction name="setCommunicationMethodNull" access="public" returntype="void" default="void" hint="Set CommunicationMethod to its NULL value'" output="false">
<cfscript>
var nullValue = getNullable().getNullstring(getClassName(), "CommunicationMethod");
setCommunicationMethod(nullValue);
</cfscript>
</cffunction>

<cffunction name="getCommunicationMethodIsNull" access="public" returntype="boolean" default="boolean" hint="Returns whether or not CommunicationMethod's value matches the set NULL value'" output="false">
<cfscript>
return getNullable().checkNullstring(getThisObject(), "CommunicationMethod", getCommunicationMethod());
</cfscript>
</cffunction>

<cffunction name="getUserGroupisLoaded" access="public" returntype="boolean" default="boolean" hint="Whether or not the composition 'UserGroup' has been loaded yet" output="false">
<cfscript>
if(NOT StructKeyExists(getLoaded(), "UserGroup"))
{
setUserGroupisLoaded(false);
}
return StructFind(getLoaded(), "UserGroup");
</cfscript>
</cffunction>

<cffunction name="setUserGroupisLoaded" access="private" returntype="void" default="void" hint="Set the loaded state of composition 'arguments.name'" output="false">
<cfargument name="loaded" type="boolean" required="true" hint="Whether or not this composition has been loaded">
<cfscript>
StructInsert(getLoaded(), "UserGroup", arguments.loaded, true);
</cfscript>
</cffunction>

<cffunction name="loadUserGroup" access="package" returntype="void" default="void" hint="Lazy load composition 'UserGroup'" output="false">
<cfif NOT getUserGroupisLoaded()>
<cflock name="transfer.load.user.user.UserGroup.#getSystem().identityHashCode(this)#" timeout="60">
<cfif NOT getUserGroupisLoaded()>
<cfscript>
getTransfer().loadManyToOne(getThisObject(), "UserGroup");
</cfscript>
</cfif>
</cflock>
</cfif>
</cffunction>

<cffunction name="unLoadUserGroup" access="private" returntype="void" default="void" hint="unload lazy load composition 'UserGroup'" output="false">
<cfif getUserGroupisLoaded()>
<cflock name="transfer.load.user.user.UserGroup.#getSystem().identityHashCode(this)#" timeout="60">
<cfif getUserGroupisLoaded()>
<cfscript>
setUserGroupisLoaded(false);
StructDelete(instance, "UserGroup");
</cfscript>
</cfif>
</cflock>
</cfif>
</cffunction>

<cffunction name="setMemento" access="public" returntype="void" default="void" hint="set the state of this object from a memento" output="false">
<cfargument name="memento" type="struct" required="true" hint="the memento to set the state with">
<cfscript>
var composite = 0;
if(NOT getIsPersisted())
{
setUserId(StructFind(arguments.memento, "UserId"));
}
setPropertyMemento(arguments.memento);
setUserGroupisLoaded(false);
if(StructKeyExists(arguments.memento, "UserGroup"))
{
composite = StructFind(arguments.memento, "UserGroup");
}
else
{
composite = StructNew();
}
setUserGroupMemento(composite);
</cfscript>
</cffunction>

<cffunction name="setPropertyMemento" access="public" returntype="void" default="void" hint="set the Property state of this object with a memento" output="false">
<cfargument name="memento" type="struct" required="true" hint="the memento to set the state with">
<cfscript>
setUserName(StructFind(arguments.memento, "UserName"));
setUserPass(StructFind(arguments.memento, "UserPass"));
setNickname(StructFind(arguments.memento, "Nickname"));
setSalutation(StructFind(arguments.memento, "Salutation"));
setFirstName(StructFind(arguments.memento, "FirstName"));
setLastName(StructFind(arguments.memento, "LastName"));
setLikeCheese(StructFind(arguments.memento, "LikeCheese"));
setLikeChocolate(StructFind(arguments.memento, "LikeChocolate"));
setLikeOther(StructFind(arguments.memento, "LikeOther"));
setLastUpdateTimestamp(StructFind(arguments.memento, "LastUpdateTimestamp"));
setAllowCommunication(StructFind(arguments.memento, "AllowCommunication"));
setHowMuch(StructFind(arguments.memento, "HowMuch"));
setCommunicationMethod(StructFind(arguments.memento, "CommunicationMethod"));
</cfscript>
</cffunction>

<cffunction name="setUserGroupMemento" access="public" returntype="void" default="void" hint="set the state of composition manytoone 'UserGroup'" output="false">
<cfargument name="memento" type="struct" required="true" hint="the memento to set the state with">
<cfscript>
var composite = 0;
if(StructIsEmpty(arguments.memento))
{
removeUserGroup();
}
else
{
composite = getComposite("user.usergroup", arguments.memento, "UserGroupId");
setUserGroup(composite);
}
</cfscript>
</cffunction>

<cffunction name="getMemento" access="public" returntype="struct" default="struct" hint="Returns the memento for all non-lazy members of this object" output="false">
<cfscript>
var memento = createObject("java", "java.util.HashMap").init();
StructInsert(memento, "UserId", getUserId());
StructInsert(memento, "transfer_isDirty", getIsDirty());
StructInsert(memento, "transfer_isPersisted", getIsPersisted());
StructInsert(memento, "transfer_isProxied", false);
StructAppend(memento, getPropertyMemento());
StructInsert(memento, "UserGroup", getUserGroupMemento());
return memento;
</cfscript>
</cffunction>

<cffunction name="getPropertyMemento" access="public" returntype="struct" default="struct" hint="returns the memento for properties" output="false">
<cfscript>
var memento = createObject("java", "java.util.HashMap").init();
StructInsert(memento, "UserName", getUserName());
StructInsert(memento, "UserPass", getUserPass());
StructInsert(memento, "Nickname", getNickname());
StructInsert(memento, "Salutation", getSalutation());
StructInsert(memento, "FirstName", getFirstName());
StructInsert(memento, "LastName", getLastName());
StructInsert(memento, "LikeCheese", getLikeCheese());
StructInsert(memento, "LikeChocolate", getLikeChocolate());
StructInsert(memento, "LikeOther", getLikeOther());
StructInsert(memento, "LastUpdateTimestamp", getLastUpdateTimestamp());
StructInsert(memento, "AllowCommunication", getAllowCommunication());
StructInsert(memento, "HowMuch", getHowMuch());
StructInsert(memento, "CommunicationMethod", getCommunicationMethod());
return memento;
</cfscript>
</cffunction>

<cffunction name="getUserGroupMemento" access="public" returntype="struct" default="struct" hint="returns the memento for manytoone UserGroup" output="false">
<cfscript>
var memento = createObject("java", "java.util.HashMap").init();
if(hasUserGroup())
{
memento = getUserGroup().getMemento();
}
return memento;
</cfscript>
</cffunction>

<cffunction name="copyValuesTo" access="public" returntype="void" default="void" hint="Copies the values of this object to one of the same class" output="false">
<cfargument name="transfer" type="transfer.com.TransferObject" required="true" hint="The object to copy values to">
<cfscript>
if(arguments.transfer.getClassName() neq "user.user")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.transfer.getClassName()#' does not match the expected class of 'user.user'");
}
arguments.transfer.setMemento(getMemento());
</cfscript>
</cffunction>

<cffunction name="getUserGroup" access="public" returntype="transfer.com.TransferObject" default="transfer.com.TransferObject" hint="Accessor for UserGroup, user.usergroup" output="false">
<cfscript>
if(NOT getUserGroupisLoaded())
{
loadUserGroup();
}
if(NOT structKeyExists(instance, "UserGroup"))
{
throw("ManyToOneNotSetException","A ManyToOne TransferObject has not been initialised.","In TransferObject 'user.user' manytoone 'user.usergroup' does not exist, when calling getUserGroup()");
}
return instance.UserGroup;
</cfscript>
</cffunction>

<cffunction name="setUserGroup" access="public" returntype="void" default="void" hint="Mutator for UserGroup, user.usergroup" output="false">
<cfargument name="transfer" type="transfer.com.TransferObject" required="true" hint="The user.usergroup to set">
<cfscript>
if(arguments.transfer.getClassName() neq "user.usergroup")
{
throw("InvalidTransferClassException","The supplied Transfer class was not the one specified in the configuration file ","The Transfer class of '#arguments.transfer.getClassName()#' does not match the expected class of 'user.usergroup'");
}
if((NOT getUserGroupisLoaded()) OR (NOT (StructKeyExists(instance, "UserGroup") AND getUserGroup().equalsTransfer(arguments.transfer))))
{
instance.UserGroup = arguments.transfer;
setIsDirty(true);
setUserGroupisLoaded(true);
}
</cfscript>
</cffunction>

<cffunction name="hasUserGroup" access="public" returntype="boolean" default="boolean" hint="Whether or not this object contains a user.usergroup" output="false">
<cfscript>
if(NOT getUserGroupisLoaded())
{
loadUserGroup();
}
return StructKeyExists(instance,"UserGroup");
</cfscript>
</cffunction>

<cffunction name="removeUserGroup" access="public" returntype="void" default="void" hint="remove the instance of user.usergroup" output="false">
<cfscript>
if(NOT getUserGroupisLoaded() OR hasUserGroup())
{
StructDelete(instance,"UserGroup");
setIsDirty(true);
setUserGroupisLoaded(true);
}
</cfscript>
</cffunction>

<cffunction name="validateCacheState" access="package" returntype="boolean" default="boolean" hint="if this object is cached, then validate that all it's composites are cached too" output="false">
<cfscript>
var iterator = 0;
var item = 0;
if(getIsPersisted() AND NOT getTransfer().validateIsCached(getThisObject()))
{
return true;
}
if(getUserGroupisLoaded() AND hasUserGroup())
{
item = getUserGroup();
if(item.getIsClone() OR NOT getTransfer().validateIsCached(item))
{
return false;
}
}
return true;
</cfscript>
</cffunction>

<cffunction name="actionAfterCreateTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when creates occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
</cfscript>
</cffunction>

<cffunction name="actionAfterDeleteTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when deletes occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
if(className eq "user.usergroup")
{
if(getUserGroupIsLoaded() AND hasUserGroup() AND getUserGroup().equalsTransfer(arguments.event.getTransferObject()))
{
removeUserGroup(arguments.event.getTransferObject());
}
}
</cfscript>
</cffunction>

<cffunction name="actionAfterUpdateTransferEvent" access="public" returntype="void" default="void" hint="Observer method action for when updates occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var className = arguments.event.getTransferObject().getClassName();
</cfscript>
</cffunction>

<cffunction name="actionAfterDiscardTransferEvent" access="public" returntype="void" default="void" hint="Observer action method for when discards occur" output="false">
<cfargument name="event" type="transfer.com.events.TransferEvent" required="true" hint="The Transfer Event Object">
<cfscript>
var discard = false;
var className = arguments.event.getTransferObject().getClassName();
if(className eq "user.usergroup")
{
if(getUserGroupIsLoaded() AND hasUserGroup() AND getUserGroup().equalsTransfer(arguments.event.getTransferObject()))
{
if(getUserGroupisLoaded())
{
unloadUserGroup();
}
}
}
if(discard)
{
getTransfer().discard(getThisObject());
}
</cfscript>
</cffunction>


